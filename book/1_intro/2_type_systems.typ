#import "../template.typ": book-style, term, dt

#show: book-style

= 类型系统概览

#linebreak()

⚠️注意：本文为早期草稿，内容不完且有措误，且#text(tracking: -0.15em)[排版]质量差。

⚠️Note: this is an early draft. It's known to be incomplet and incorrekt, and it has lots of b#text(tracking: -0.15em)[ad] fo#text(tracking: -0.15em)[rm]atting.

#linebreak()

那么，为什么要构建类型系统呢？答案显而易见：因为类型系统很棒，在理论上很有趣。但其次，因为它们确实很有用。

让我们先从一些背景知识开始。如果你想的话，理论上你可以跳过这部分，直接看代码。但在深入实现之前，了解一些软性的背景知识是很有用的。

任何类型系统的讨论都以 #term[$lambda$ 演算 (Lambda calculus)] 开始，这是阿隆佐·邱奇于 1930 年代开发的一种用于表达计算的形式系统。它是最小化的、泛用的程序语言。它的语法仅包由三种元素组成：变量、函数抽象（定义一个匿名函数）和函数应用（调用一个函数）。例如，简单返回其输入的恒等函数可以写作 $lambda x dt x$。麻雀虽小，五脏俱全——任何可计算的问题都可以用 $lambda$ 演算表达并求解。

接下来，我们将介绍类型系统。一个类型系统就是为程序中的各种结构——例如变量、表达式和函数——赋予*类型*的一组规则。类型系统的首要目的是阻止诸如用数字除以字符串之类的无意义操作，从而减少错误。验证程序是否遵守其程序语言类型规则的过程称作类型检查。

== 类型之系统

任何类型系统的核心都是一套用于对程序进行逻辑推理的形式化规则。这些推理被称作#term[判断 (judgement)]。判断就是断言一段代码具有某种属性。最常见的判断就是#term[类型判断 (typing judgement)]，即断言在特定的#term[语境 (context)] 中，给定的表达式具有特定的类型。我们用“十字转门”符号 $tack$ 来形式化地表示这一点。

类型判断的一般形式看起来就像这样：

$
  Gamma tack e : T
$

这句话读作“在语境 $Gamma$ 中，表达式 $e$ 具有类型 $T$”。语境 $Gamma$ 是变量名到其类型的映射。例如，#linebreak() $x : "Int", f : "Bool" -> "Int"$ 是这样一个语境，其中变量 $x$ 具有类型 $"Int"$，而变量 $f$ 具有函数类型 $"Bool" -> "Int"$。当我们进入程序中更深层的作用域，例如进入函数体时，我们用新的变量绑定扩展语境。这通常写作 $Gamma, x : T$，这表示“语境 $Gamma$ 中加入了一个新的绑定，该绑定表明变量 $x$ 具有类型 $T$”。

类型判断是通过#term[推理规则 (inference rule)] 导出的。推理规则指出，如果你能证明一组判断——也就是前提，那么你就能得出另一个判断——也就是结论。在形式化类型系统中，推理规则都遵循一致的结构化模式，因而易于阅读和理解。每条规则都具有如下形式：

$
  (quad "前提" quad) / (quad "结论" quad) wide ("规则名")
$

这种记法应该读作：“如果横线上面的所有前提成立，则横线下面的结论也成立”。前提代表必须满足的条件，而结论代表当条件成立时我们能推出什么。规则名则提供了一个方便的标签，以便在讨论和证明中引用规则。

如果一条规则没有前提，那么它就是一条#term[公理 (axiom)]，一个无需论证、不言自明的事实。例如，一条用于确定字面量零的类型的公理规则可以写作：

$
  () / (Gamma tack 0 : "Int") wide ("T-Zero")
$

这条规则的横线上面没有前提，因此它是公理。它表示在任何语境 $Gamma$ 中，字面量 $0$ 都具有 $"Int"$ 类型。公理通常被用来处理字面值之类简单情况（有时它们也被称作#term[基本类型 ground type]）。

变量查找规则是几乎每个类型系统都有的一条基本规则，它使我们能在语境中找出变量的类型：

$
  (x : T in Gamma) / (Gamma tack x : T) wide ("T-Var")
$

这条规则不是公理，因为它有一个前提。整条规则读作：“若*类型绑定* $x : T$ 存在于语境 $Gamma$ 中，则我们可以得出在语境 $Gamma$ 中，*表达式* $x$ 具有 $T$ 类型”。它形式化地定义了在当前环境中查找一个变量的类型这一动作。

通过定义一系列这样的规则，我们就能创造一个完整的类型能够系统。每条规则都定义了如何确定某一类表达式——如函数调用、字面值或者 `if-then-else` 块——的类型。例如，函数应用的规则会要求我们先证明如下前提：函数具有函数类型 $T -> U$，且参数具有相应的输入类型 $T$。如果我们能证明这些前提，则规则允许我们得出整个函数应用表达式具有输出类型 $U$。通过反复应用这些规则，我们就能从关于字面量的公理出发，逐步构造出一棵推导树，并最终汇聚成关于整个程序类型的一个大判断，从而证明程序是#term[类型良定的 (well-typed)]。

== 判断

函数应用的类型规则是一条常见的带有多个前提的推理规则，它决定函数应用的类型。在 $lambda$ 演算中，函数应用就是一个简单的表达式 $e_1 med e_2$，其中 $e_1$ 是函数，$e_2$ 是参数。要为这个表达式赋予类型，我们首先必须确定函数 $e_1$ 和参数 $e_2$ 各自的类型。而这条规则——通常称作“应用”或“函数消去 ($-> E$)”——写作：

$
  (Gamma tack e_1 : T_1 -> T_2 wide Gamma tack e_2 : T_1)
  /
  (Gamma tack e_1 med e_2 : T_2)
  wide
  ("T-App")
$

这条规则的横线上面有两个前提，这表明要得出“函数应用 $e_1 med e_2$ 具有类型 $T_2$”这一结论，我们要先在同一个语境 $Gamma$ 下证明两件事：首先，我们必须证明 $e_1$ 具有函数类型，写作 $T_1 -> T_2$，也就是说它接受类型为 $T_1$ 的输入，产生类型为 $T_2$ 的输出；然后，我们还必须证明参数 $e_2$ 具有正确的输入类型 $T_1$。如果两个前提都成立，则这条规则允许我们推导出整个表达式 $e_1 med e_2$ 的输出具有函数 $e_1$ 的输出类型，即 $T_2$。

现在，让我们来看一个例子：对表达式 $f x$ 作类型检查的过程将会串联三条推理规则。我们会在包含绑定 $f$ 和 $x$ 的语境 $Gamma$ 中工作，特别地，$Gamma = f : "Int" -> "Bool", x : "Int"$。我们的目标是证明 $Gamma tack f med x : "Bool"$

我们的推导从两个简单的变量查找开始，这将构成规则 T-App 的前提：

1. 查找变量 $f$：我们使用规则 T-Var 来确定变量 $f$ 的类型。由于 $f : "Int" -> "Bool"$ 存在于语境 $Gamma$ 中，我们可以得出：

$
  (f : "Int" -> "Bool" in Gamma)
  /
  (Gamma tack f : "Int" -> "Bool")
$

2. 查找变量 $x$：用类似的方式，我们可以确定变量 $x$ 的类型。由于 $x : "Int"$ 存在于语境 $Gamma$ 中，我们可以得出：

$
  (x : "Int" in Gamma)
  /
  (Gamma tack x : "Int")
$

3. 函数应用：现在我们已经有了运用规则 T-App 所必须的前提。我们将规则中的 $e_1$ 替换为 $f$，$e_2$ 替换为 $x$，$T_1$ 替换为 $"Imt"$，$T_2$ 替换为 $"Bool"$。因为前提已经在前两步推导中得以证明，现在我们可以形成最终结论：

$
  (Gamma tack f : "Int" -> "Bool" wide Gamma tack x : "Int")
  /
  (Gamma tack f med x : "Bool")
$

综合以上内容，我们可以将完整的推导过程表示为嵌套推理规则的树状图，展示了如何从变量查找开始逐步构建出最终判断：

$
  (
    display(
      (f : "Int" -> "Bool" in Gamma)
      /
      (Gamma tack f : "Int" -> "Bool")
    )
    wide
    display(
      (x : "Int" in Gamma)
      /
      (Gamma tack x : "Int")
    )
  )
  /
  (Gamma tack f med x : "Bool")
$

这个嵌套结构被称作#term[推导树 (derivation tree)] 或#term[推理树 (inference tree)]。树中的每个节点都对应于一条推理规则的一次应用。这棵树可视化地展示了类型检查如何从基本事实（语境中变量的类型）开始，逐步应用规则，最终得到结论——也就是整个复杂表达式的类型。在这个例子中，树根是类型判断 $Gamma tack f med x : "Bool"$，而它的两个子节点则是关于 $f$ 和 $x$ 的类型判断，而它们又是各自通过 T-Var 得出的。这一过程可以扩展到更大的程序，派生树会不断增长，以反应程序的结构和类型信息的逻辑流。

== 词项和类型

历史上，许多程序语言都强制要求不同抽象层之间严格分离，这种概念被称为#term[分层 (stratification)]。在这一模型中存在一个“#term[词项 (term)] 语言”和一个“类型语言”，它们在语法上泾渭分明。词项语言由能够确实地计算出值、在运行时被执行的表达式构成，例如 5 + 2 或 $"if" x "then" y "else" z$。而类型语言则由描述词项的表达式构成，例如 $"Int"$ 或者 $"Bool" -> "Bool"$。两个世界之间如有云泥之异，类型不能出现在词项的位置，反之亦然。

这一分层机制还可进一步扩展。要为类型语言带来秩序，名为“#term[种类 (kind)] 语言”的第三层常常会被引入。一个#term[种类]可以被视为“类型之类型”。例如，像 $"Int"$ 这样的具体类型具有最简单的#term[种类] $*$（通常读作“类型”）。而 $"List"$ 这样的类型构造子自身却不是一个类型，它是某种接受类型作为参数，产生一个新类型的东西，例如它可以接受 $"Int"$ 并产生 $"List" "Int"$。因此，$"List"$ 的#term[种类]为#linebreak()$* -> *$。这形成了一个严格的层级结构：词项按类型划分，类型按#term[种类]划分。这种清晰的划分使得类型检查更简单、更可预测。

// TODO 作者这宇宙层级讲得一坨屎，明天询问下专家意见，看这地方怎么补。

然而，现代的强大类型系统设计的一个主要趋势是摈弃这种严格的分层，将词项语言和类型语言统一到一个单一的、一致的语法框架中。在这些统一系统中，“值”（词项）和“描述”（类型）的界限开始变得模糊。语言的文法允许表达式在不同的“层级”或“#term[宇宙 (universe)]”上被解释。例如，宇宙 $"Type"_0$ 中包含 $"Bool"$ 这样的简单类型，而更高层的宇宙 $"Type"_1$ 中唯一的成员就是 $"Type"_0$。这样一来，你就可以编写作用域类型上的函数，这是#term[依值类型 (dependent type)] 语言的一个关键特性，稍后会详细说明。

为了具体说明这一点，考虑一个简单的、分层的算术语言。我们为其分别定义词项语言 $e$ 和对应的类型语言 $tau$。词项是实际的可以计算的表达式，而类型则是可被赋予词项的静态标签：

$
  & "terms" & wide & e ::= n | e_1 + e_2 | "iszero"(e) | "true" | "false" | "if" e_1 "then" e_2 "else" e_3 \
  & "types" & wide & tau ::= "Nat" | "Bool"
$

词项语言 $e$ 定义了自然数 $n$、加法、一个用于检查是否为零的函数、布尔常量和条件表达式。类型语言 $tau$ 则要简单许多，它只包含类型 $"Nat"$ 和 $"Bool"$。在这个分层系统中，像 $"Nat" + 5$ 这样的表达式是一个语法错误，因为 $"Nat"$ 属于类型语言，不能被用于加法这样的词项级操作。在一个更加现代、统一的系统中，这种严格的区别会被放宽。