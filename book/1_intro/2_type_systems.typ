#import "../template.typ": book-style, term, dt, bad-formatting

#show: book-style

// translated at commit hash: 349422d22a371bb5f7edc80f10f6a463f6628081

= 类型系统概览

#linebreak()

#bad-formatting

那么，为什么要构建类型系统呢？答案显而易见：因为类型系统很棒，在理论上很有趣。但其次，因为它们确实很有用。让我们从背景知识开始。如果你想的话，你可以跳过这部分直接去看公式和代码。但在深入理论和实现之前，了解一些软性的背景知识是很有用的。

任何类型系统的讨论都以 #term[$lambda$ 演算 (Lambda calculus)] 开始，这是阿隆佐·邱奇于 1930 年代开发的一种用于表达计算的形式系统。它是最小化的、泛用的程序语言。它的语法仅由三种元素组成：变量、函数抽象（定义一个匿名函数）和函数应用（调用一个函数）。例如，简单返回其输入的恒等函数可以写作 $lambda x dt x$。麻雀虽小，五脏俱全——任何可计算的问题都可以用 $lambda$ 演算表达并求解。

接下来，我们将介绍类型系统。一个类型系统就是为程序中的各种结构——例如变量、表达式和函数——赋予*类型*的一组规则。类型系统的首要目的是阻止诸如用数字除以字符串之类的无意义操作，从而减少错误。验证程序是否遵守其程序语言类型规则的过程称作类型检查。

== 类型之系统

任何类型系统的核心都是一套用于对程序进行逻辑推理的形式化规则。这些推理被称作#term[判断 (judgement)]。判断就是断言一段代码具有某种属性。最常见的判断就是#term[类型判断 (typing judgement)]，即断言在特定的#term[语境 (context)] 中，给定的表达式具有特定的类型。我们用“十字转门”符号 $tack$ 来形式化地表示这一点。

类型判断的一般形式看起来就像这样：

$
  Gamma tack e : tau
$

这句话读作“在语境 $Gamma$ 中，表达式 $e$ 具有类型 $tau$”。语境 $Gamma$ 是变量名到其类型的映射。例如，在语境 ${ x : "Int", f : "Bool" -> "Int" }$ 中，变量 $x$ 具有类型 $"Int"$，而变量 $f$ 具有函数类型 $"Bool" -> "Int"$。当我们进入程序中更深层的作用域，例如进入函数体时，我们用新的变量绑定扩展语境。这通常写作 $Gamma, x : tau$，这表示“语境 $Gamma$ 中加入了一个新的绑定，该绑定表明变量 $x$ 具有类型 $tau$”。

类型判断是通过#term[推理规则 (inference rule)] 推导出的。推理规则指出，如果你能证明一组判断——也就是前提，那么你就能得出另一个判断——也就是结论。在形式化类型系统中，推理规则都遵循一致的结构化模式，因而易于阅读和理解。每条规则都具有如下形式：

$
  (quad "前提" quad) / (quad "结论" quad) quad ["规则名"]
$

这种记法应该读作：“如果横线上面的所有前提成立，则横线下面的结论也成立”。前提代表必须满足的条件，而结论代表当条件成立时我们能推出什么。规则名则提供了一个方便的标签，以便在讨论和证明中引用规则。

如果一条规则没有前提，那么它就是一条#term[公理 (axiom)]，一个无需论证、不言自明的真命题。例如，一条用于确定字面量零的类型的公理规则可以写作：

$
  () / (Gamma tack #[`0`] : "Int") quad [T"-Zero"]
$

这条规则的横线上面没有前提，因此它是公理。它表示在任何语境 $Gamma$ 中，字面量 $0$ 都具有 $"Int"$ 类型。公理通常会被用来处理字面值之类简单情况。

变量查找规则 $[T"-Var"]$ 是几乎每个类型系统都有的一条基本规则，它使我们能在语境中找出变量的类型：

$
  (x : tau in Gamma) / (Gamma tack x : tau) quad [T"-Var"]
$

这条规则不是公理，因为它有一个前提。整条规则读作：“若*类型绑定* $x : tau$ 存在于语境 $Gamma$ 中，则我们可以得出在语境 $Gamma$ 中，*表达式* $x$ 具有 $tau$ 类型”。它形式化地定义了在当前环境中查找一个变量的类型这一动作。

通过定义一系列这样的规则，我们就能创造一个完整的类型系统。每条规则都定义了如何确定某一类表达式——如函数调用、字面值或者 `if-then-else` 块——的类型。例如，函数应用的规则会要求我们先证明如下前提：函数具有函数类型 $tau -> tau'$，且参数具有相应的输入类型 $tau$。如果我们能证明这些前提，则规则允许我们得出整个函数应用表达式具有输出类型 $tau'$。通过反复应用这些规则，我们就能从关于字面量的公理出发，逐步构造出一棵推导树，并最终汇聚成关于整个程序类型的一个大判断，从而证明程序是#term[类型良定的 (well-typed)]。

== 判断

函数应用的类型规则是一条常见的带有多个前提的推理规则，它决定函数应用的类型。在 $lambda$ 演算中，函数应用就是一个简单的表达式 $e_1 med e_2$，其中 $e_1$ 是函数，$e_2$ 是参数。要为这个表达式赋予类型，我们首先必须确定函数 $e_1$ 和参数 $e_2$ 各自的类型。而这条规则——通常称作“应用”或“函数消去 ($-> E$)”——写作：

$
  (Gamma tack e_1 : tau_1 -> tau_2 wide Gamma tack e_2 : tau_1)
  /
  (Gamma tack e_1 med e_2 : tau_2)
  quad
  [T"-App"]
$

这条规则的横线上面有两个前提，这表明要得出“函数应用 $e_1 med e_2$ 具有类型 $tau_2$”这一结论，我们要先在同一个语境 $Gamma$ 下证明两件事：首先，我们必须证明 $e_1$ 具有函数类型 $tau_1 -> tau_2$，也就是说它接受类型为 $tau_1$ 的输入，产生类型为 $tau_2$ 的输出；然后，我们还必须证明参数 $e_2$ 具有正确的输入类型 $tau_1$。如果两个前提都成立，则这条规则允许我们推导出整个表达式 $e_1 med e_2$ 的输出具有函数 $e_1$ 的输出类型，即 $tau_2$。

现在，让我们来看一个例子：对表达式 $f x$ 作类型检查的过程将会串联三条推理规则。我们会在包含绑定 $f$ 和 $x$ 的语境 $Gamma$ 中工作，特别地，$Gamma = { f : "Int" -> "Bool", x : "Int" }$。我们的目标是证明 $Gamma tack f med x : "Bool"$。

我们的推导从两个简单的变量查找开始，这将构成规则 $[T"-App"]$ 的前提：

1. 查找变量 $f$：我们使用规则 $[T"-Var"]$ 来确定变量 $f$ 的类型。由于 $f : "Int" -> "Bool"$ 存在于语境 $Gamma$ 中，我们可以得出：

$
  (f : "Int" -> "Bool" in Gamma)
  /
  (Gamma tack f : "Int" -> "Bool")
$

2. 查找变量 $x$：用类似的方式，我们可以确定变量 $x$ 的类型。由于 $x : "Int"$ 存在于语境 $Gamma$ 中，我们可以得出：

$
  (x : "Int" in Gamma)
  /
  (Gamma tack x : "Int")
$

3. 函数应用：现在我们已经有了运用规则 $[T"-App"]$ 所必须的前提。我们将规则中的 $e_1$ 替换为 $f$，$e_2$ 替换为 $x$，$T_1$ 替换为 $"Int"$，$T_2$ 替换为 $"Bool"$。因为前提已经在前两步推导中得以证明，现在我们可以形成最终结论：

$
  (Gamma tack f : "Int" -> "Bool" wide Gamma tack x : "Int")
  /
  (Gamma tack f med x : "Bool")
$

综合以上内容，我们可以将完整的推导过程表示为嵌套推理规则的树状图，展示了如何从变量查找开始逐步构建出最终判断：

$
  (
    display(
      (f : "Int" -> "Bool" in Gamma)
      /
      (Gamma tack f : "Int" -> "Bool")
    )
    wide
    display(
      (x : "Int" in Gamma)
      /
      (Gamma tack x : "Int")
    )
  )
  /
  (Gamma tack f med x : "Bool")
$

这个嵌套结构被称作#term[推导树 (derivation tree)] 或#term[推理树 (inference tree)]。树中的每个节点都对应于一条推理规则的一次应用。这棵树可视化地展示了类型检查如何从基本事实（语境中变量的类型）开始，逐步运用规则，最终得到结论——也就是整个复杂表达式的类型。在这个例子中，树根是类型判断 $Gamma tack f med x : "Bool"$，而它的两个子节点则是关于 $f$ 和 $x$ 的类型判断，而它们又是各自通过 $[T"-Var"]$ 得出的。这一过程可以扩展到更大的程序，推导树会不断增长，以反映程序的结构和类型信息的逻辑流。

== 词项和类型

历史上，许多程序语言都强制要求不同抽象层之间严格分离，这种概念被称为#term[分层 (stratification)]。在这一模型中存在一个“#term[词项 (term)] 语言”和一个“类型语言”，它们在语法和概念上泾渭分明。词项语言由能够确实地计算出值、在运行时被执行的表达式构成，例如 $5 + 2$ 或 $"if" x "then" y "else" z$。而类型语言则由描述词项的表达式构成，例如 $"Int"$ 或者 $"Bool" -> "Bool"$。两个世界的居民如方枘圆凿，类型不能出现在词项的位置，反之亦然。

这一分层机制还可进一步扩展。要为类型语言带来秩序，名为“#term[种类 (kind)] 语言”的第三层常常会被引入。一个#term[种类]可以被视为“类型之类型”。例如，像 $"Int"$ 这样的具体类型具有最简单的#term[种类] $*$（通常读作“类型”）。而 $"List"$ 这样的类型构造子自身却不是一个类型，它是某种接受类型作为参数，产生一个新类型的东西，例如它可以接受 $"Int"$ 并产生 $"List" "Int"$。因此，$"List"$ 的#term[种类]为#linebreak()$* -> *$。这形成了一个严格的层级结构：词项按类型划分，类型按#term[种类]划分。这种清晰的划分使得类型检查更简单、更可预测。

// TODO 作者这宇宙层级讲得一坨屎，明天询问下专家意见，看这地方怎么补。

然而，现代的强大类型系统设计的一个主要趋势是摈弃这种严格的分层，将词项语言和类型语言统一到一个单一的、一致的语法框架中。在这些统一系统中，“值”（词项）和“描述”（类型）的界限开始变得模糊。语言的文法允许表达式在不同的“层级”或“#term[宇宙 (universe)]”中被解释。例如，宇宙 $"Type"_0$ 中包含 $"Bool"$ 这样的简单类型，而更高层的宇宙 $"Type"_1$ 中唯一的成员就是 $"Type"_0$。这样一来，你就可以编写作用于类型上的函数，这是#term[依值类型 (dependent type)] 语言的一个关键特性，稍后会详细说明。

为了具体说明这一点，考虑一个简单的、分层的算术语言。我们为其分别定义词项语言 $e$ 和对应的类型语言 $tau$。词项是实际的可以计算的表达式，而类型则是可被赋予词项的静态标签：

$
  & "词项" & wide & e ::= n | e_1 + e_2 | "iszero"(e) | "true" | "false" | "if" e_1 "then" e_2 "else" e_3 \
  & "类型" & wide & tau ::= "Nat" | "Bool"
$

词项语言 $e$ 定义了自然数 $n$、加法、一个用于检查是否为零的函数、布尔常量和条件表达式。类型语言 $tau$ 则要简单许多，它只包含类型 $"Nat"$ 和 $"Bool"$。在这个分层系统中，像 $"Nat" + 5$ 这样的表达式是一个语法错误，因为 $"Nat"$ 属于类型语言，不能被用于加法这样的词项级操作。在一个更加现代、统一的系统中，这种严格的区别会被放宽。

== 类型检查和类型重建

验证程序是否符合其类型规则的过程称作类型检查，而一个与之相关且具有重大历史意义的挑战是#term[类型重建 (type reconstruction)]，它还有一个更常见的名字——#term[类型推断 (type inference)]。类型推断的目标是让编译器能推导出表达式的类型，而无需程序员手写显式类型注解。多年以来，为日益强大的语言开发能够执行完全类型推断的算法一直是活跃且至关重要的研究领域，其前景极具吸引力：无需繁琐的手动标注每个变量和函数，即可实现静态类型系统的所有安全保障。

而近几十年来，人们对完全类型推断的关注度有所下降。主要原因是，随着类型系统变得越来越强大、复杂，完全类型推断在计算上变得难以处理，在很多时候甚至是不可判定的。现代程序语言通常包含#term[高秩多态 (higher-rank polymorphism, 将多态函数作为参数传递)]、#term[广义代数数据类型 (Generalized Algebraic Data Types, GADTs)]，以及各种类型级编程——在这些类型级编程特性中，类型本身就可能涉及计算。对于这些系统而言，不存在一种能够为任意表达式推断出“唯一最佳类型”的通用算法。试图这样做会导致算法变得极其复杂，推导出的类型也会变得连篇累牍，令人百思不解。

因此，许多现代的静态类型语言最终采用了一种既实用又优雅的折衷方案：#term[双向类型检查 (bidirectional type checking)]。双向检查器不再采用“始终尝试推断类型”这种单一的模式，而是采用两种不同的模式：“检查”模式和“合成”模式：

- 检查模式：在这个模式下，算法检验表达式 $e$ 是否符合已知的期望类型 $tau$。信息流从语境“向下”流入到表达式中。我们是在提问：“我们能证明表达式 $e$ 具有类型 $tau$ 吗？”
- 合成模式：在这个模式下，算法在没有任何期望的情况下，计算——或者说“合成”——表达式 $e$ 的类型。信息从表达式的组件中“向上”流动。我们是在提问，“$e$ 的类型是什么？”

这种二元性提供了一个强大的框架。语言设计者可以指定哪些语法结构需要注解，哪些不需要。例如，顶层函数的参数可能需要显式注解（让检查器在处理函数体时处于检查模式），但函数体内局部变量的类型可以被推断（合成）。这种方法巧妙地规避了完全推断的难题，它要求程序员仅在可能产生歧义的关键边界处提供注解。它提供了一种“两全其美”的方案：既有局部推断的便利性，又有显式注解在复杂、多态或歧义代码部分的清晰性和强大功能，从而在表达力、可用性和可实现性之间找到了理论上的最佳平衡点。稍后我们将对此进行更详细的讨论。

== 前沿领域

自 20 世纪 70 年代末以来，研究人员就注意到了计算、形式逻辑和范畴论之间存在着惊人的结构相似性。这一发现有时被称作#link("https://ncatlab.org/nlab/show/computational+trilogy")[“计算三位一体论”]，它揭示了三个学科正从不同的角度研究相同的基本数学结构。这些联系是真实存在的，在数学上是严谨的，不过它们对日常编程的实际意义尚无定论，仍是一个需要持续研究的问题。

这里的核心洞见是#term[柯里-霍华德同构 (Curry-Howard Isomorphism)]，它建立了类型系统与逻辑证明系统之间的形式对偶性。在这种对应关系下，类型可以被解读为逻辑命题，而类型良定的程序则构成了该命题的构造性证明。这并非简单的类比：相同的形式结构出现在了两个领域，并且在一个领域中证明的结果可以直接迁移到另一个领域中。

#colbreak()

这种对应关系可以自然而然地延伸到多个方向：

- 一个逻辑*命题*对应于编程中的一个*类型*，而类型又对应于范畴论中的*对象*；
- 一个*证明*对应于一段具有该类型的*程序*（或者词项），而程序又对应于对象间的#term[*态射 (morphism)*]；
- *证明简化*对应于*程序求值*，而程序求值又对应于态射的#term[组合 (composition)]。

那么，这在实践中能给我们带来什么好处呢？考虑用于获取列表中第一个元素的函数，像 `head : List T -> T` 这样的简单函数签名作出了一个实现无法兑现的承诺：它声明对于任意列表都会返回一个类型为 $T$ 的值，但空列表中没有任何值，自然也就没有“第一个元素”。因此这个类型是一个假命题。

一个更诚实的签名是 `safeHead : List T -> Maybe T`，这里 `Maybe` 类型会强制调用者处理值不存在的可能性。这个例子很简单，但它切中肯綮：类型系统强制执行一种契约，而编译器静态地检查这种契约。类型所表达的命题实际上对任何通过类型检查的程序都成立。

依值类型则更进一步。在 Agda、Rocq 和 Lean 这样的语言中，你可以定义一个 `SortedList T` 类型，其值为列表以及列表内容已排序的证明。而一个类型签名为 #linebreak() `merge : SortedList T -> SortedList T -> SortedList T` 的函数不仅要合并两个列表，还要给出结果已经排序的证明。编译器会拒绝任何不能提供证明的实现。

这确实非常强大，但其代价却很容易被低估。编写证明需要大多数程序员不具备的专业知识。证明的负担可能比实现工作量高出一个数量级。证明辅助工具在自动化方面取得了显著进展，但能够自动推导出深层正确性的世界尚在千里之外。支持这些特性的语言仍然比较小众，主要用于关键系统的形式化验证和数学研究。

这里有一个诱人的设想：如果类型是命题，程序是证明，那么或许我们可以明确定义想要的类型，然后让计算机自动合成程序。这就是基于规范进行程序合成的理想状态。然而，现实情况远没有那么理想。目前的合成工具适用于规模较小、约束较多的问题。如何从复杂规范中生成正确的实现仍是一个开放课题，现有的实用工具也只能处理有限的领域。

随着机器学习系统越来越多地被用来生成代码，类型系统为建立信任提供了一种途径。类型检查器是一种验证器：它只接受符合其规则的程序，无论代码是人写的，还是大语言模型写的。更丰富的类型系统提高了可接受代码的标准，因而能在部署前捕获更多错误。这为在更富表达力的类型系统上投入资源提供了一个合理的工程论据。但值得注意的是，我们在实际系统中关注的大多数属性，例如性能、抵御侧信道攻击的安全性或分布式状态的正确处理，仍然超出了当前类型系统能够表达的范围。

逻辑、计算和范畴论之间的理论联系精妙绝伦，几十年来一直指导着程序语言的设计。这些联系表明，这些结构中蕴含着某种深刻而统一的本质。然而，将理论转化为程序员实际可用的工具仍是一项持续的工作。理论上的可能性与实际应用之间存在着巨大的差距，弥合这一差距需要对证明自动化、语言设计和工具开发进行持续的研究。

这些理念值得深入研究，它们或许不会立即改变你的软件编写方式，但它们揭示了代码背后的数学本质。理解类型为何如此运作，以及它们能够表达什么，能让你成为更优秀的工程师和语言设计者。这种理解本身就是一种回报。
